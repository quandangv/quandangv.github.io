<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="stylesheet" href="color.css"/>
    <link rel="stylesheet" href="index.css"/>
    <link rel="stylesheet" href="tooltip.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Recursive:slnt,wght,CASL,CRSV,MONO@-10..0,300..1000,0..1,0..1,0..1&display=swap">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <script src='theme.js'></script>
    <script src='tooltip.js'></script>
    <script src='icon.js'>/*This depends on rootStyle in theme.js*/</script>
    <script>
      function selectElement(elem) {
        const range = document.createRange();
        range.selectNodeContents(elem);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
      function assert(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }
      const nonbreakSpace = '\u00A0'
      function similar(word1, word2) {
        if (word1.length > word2.length) {
          const tmp = word2
          word2 = word1
          word1 = tmp
        } else if (word1.length == word2.length) {
          for (let i = 0, error = 0; i < length; i++)
            if (word1[i] !== word2[i])
              if (++error > 3)
                return false
          return true
        }
        for (let i = 0, delta = 0; i < word2.length; i++)
          if (word1[i - delta] !== word2[i])
            if (++delta > 3)
              return false
        return true;
      }
      function log2(value, accuracy=20) {
        let int = 0n
        for (let tmp = value; tmp > 1n; tmp >>= 1n, int++);
        let result = Number(int)
        let threshold = 1n << BigInt(int)
        const sizeLimit = 2 ** accuracy
        for (let unit = 1, size = Number(int); value != 0; unit++, size *= 2) {
          if (value === threshold) break
          if (size > sizeLimit*2) {
            threshold >>= BigInt(size - sizeLimit)
            value >>= BigInt(size - sizeLimit)
            size = sizeLimit
          }
          value *= value
          threshold *= threshold
          if (value > threshold * 2n) {
            result += 2 ** -unit
            threshold <<= 1n
            size++
          }
        }
        return result
      }
    </script>
    <div id="root">
      <div id='suggestions'>
        <span><script>
            const errors = document.scripts[document.scripts.length - 1].parentNode;
            const suggestions = errors.parentNode;
            errors.removeChild(errors.lastChild)
            errors.createElement = function() {
              const elem = document.createElement('span')
              elem.className = 'strong'
              const text = document.createElement('span')
              elem.appendChild(text)
              elem.textElem = text
              makeTooltipTrigger(elem)
              elem.onclick = function() {
                const range = document.createRange()
                range.selectNodeContents(input.childNodes[0])
                range.setStart(range.startContainer, this.range[0])
                range.setEnd(range.endContainer, this.range[1] - 1)
                const sel = window.getSelection()
                sel.removeAllRanges()
                sel.addRange(range)
              }
              return elem
            }
            errors.setItem = function(elem, item, suffix) {
              elem.textElem.innerText = item.text + suffix
              elem.classList.toggle('tooltiptrigger', !!item.longText)
              elem.tooltip.innerText = item.longText + suffix
              elem.range = [item.start, item.end]
            }
            errors.list = []
            let suffix = nonbreakSpace
            errors.update = function(list) {
              this.list = list
              let listI = list.length - 1
              let i = this.childElementCount - 1
              for (; i >= 0 && listI >= 0; i--) /*pick-existing*/ {
                const elem = this.children[i]
                if (elem.classList.contains('hidden') || similar(elem.textElem.innerText, list[listI].text+suffix)) /*pick-criteria*/ {
                  elem.classList.toggle('hidden', false)
                  elem.tooltip.updatePos() // mobile-tooltip
                  elem.style.display = null
                  this.setItem(elem, list[listI], suffix)
                  listI--
                } else {
                  elem.classList.toggle('hidden', true)
                }
              }
              for (; i >= 0; i--)
                this.children[i].classList.toggle('hidden', true)
              for (;listI >= 0; listI--) /*create new children for the remaining items*/ {
                const elem = this.createElement()
                this.prepend(elem)
                elem.classList.toggle('hidden', false)
                this.setItem(elem, list[listI], suffix)
              }
            }
            function appendCmd(text) {
              let cmd = input.innerText
              if (errors.list.find(item => item.text.startsWith('unexpected ')))
                cmd = cmd.trim().substring(0, cmd.lastIndexOf(' '))
              input.changeText(cmd.trim() + ' ' + text + ' ')
            }
            // pick-existing: pick available existing children to display list element
            // pick-criteria: don't pick already visible children to avoid sudden text blinking when the new text is set, but still pick visible children that have similar text
            // mobile-tooltip: on mobile, the tooltip would unwantedly appear if it was previously triggered on a hidden element. We can't stop it from appearing, so we remedy by updating its position
        </script></span><span><script>
            function createSuggestion() {
              const elem = document.createElement('span')
              const text = document.createElement('span')
              text.id = 'text'
              elem.appendChild(text)
              elem.textElem = text
              elem.onclick = () => appendCmd(text.innerText)
              makeTooltipTrigger(elem)
              return elem
            }
            const medAnimTime = parseFloat(rootStyle.getPropertyValue('--medAnimTime'))*1000
            const paramOptions = document.scripts[document.scripts.length - 1].parentNode;
            paramOptions.removeChild(paramOptions.lastChild)
            paramOptions.setItem = function(param, item, suffix) {
              param.textElem.innerText = item.text + suffix
              param.tooltip.innerText = item.help || ''
              param.suggestion = item.suggestion
              console.log(item)
              const type = item.type
              if (!type.noInput) {
                let inputHelp = ''
                inputHelp = 'enter ' + type.desc
                param.enterBtn.tooltip.innerText = inputHelp
                param.enterBtn.classList.toggle('tooltiptrigger', !!inputHelp)
              } else
                param.noInput = type.noInput
            }
            paramOptions.createElement = function() {
              const param = createSuggestion()
              const input = document.createElement('span')
              input.id = 'input'
              input.contentEditable = true
              param.input = input
              param.appendChild(input)
              function trigger() {
                const paramName = param.textElem.innerText
                if (!paramName.includes('<'))
                  appendCmd(paramName)
                appendCmd(input.innerText)
              }
              input.onkeydown = function(e) {
                if (e.keyCode === enterKey) e.preventDefault()
              }
              input.onkeyup = function(e) {
                if (e.keyCode === enterKey && this.innerText.trim !== '')
                  trigger()
              }
              const enterBtn = document.createElement('span')
              enterBtn.innerText = nonbreakSpace + nonbreakSpace + nonbreakSpace + nonbreakSpace
              enterBtn.className = 'icon'
              enterBtn.style.backgroundImage = 'var(--icon-enter)'
              enterBtn.id = 'enter'
              makeTooltipTrigger(enterBtn, '', param)
              enterBtn.onclick = function(e) {
                trigger()
                e.stopPropagation()
              }
              param.enterBtn = enterBtn
              param.appendChild(enterBtn)
              input.onmousedown = e => e.inputClick = true
              param.onmousedown = function(e) /*hold-focus*/ {
                if (this.classList.contains('active') && !e.inputClick)
                  e.preventDefault()
              }
              param.onclick = function() {
                if (!this.classList.contains('active')) /*param-deploy*/ {
                  if (this.noInput) {
                    appendCmd(this.textElem.innerText)
                  } else {
                    input.innerText = this.suggestion
                    this.classList.toggle('active', true)
                    this.classList.toggle('tooltiptrigger', false)
                    setTimeout(() => this.enterBtn.triggerTooltip(2500), medAnimTime)
                    selectElement(input)
                  }
                }
              }
              input.onblur = function() {
                param.classList.toggle('active', false)
                param.classList.toggle('tooltiptrigger', true)
                param.enterBtn.classList.toggle('triggered', false)
              }
              return param
              // param-deploy: check if the parameter is not already deployed. If so, deploy its content
              // hold-focus: if the parameter is deployed and a click lands outside the input but inside the param, cancel that click and keep the focus of the input so that the undeploy listener isn't triggered
            }
            paramOptions.update = errors.update
        </script></span><span><script>
            const childOptions = document.scripts[document.scripts.length - 1].parentNode;
            childOptions.removeChild(childOptions.lastChild)
            childOptions.createElement = createSuggestion
            childOptions.setItem = function(elem, item, suffix) {
              elem.textElem.innerText = item.text + suffix
              elem.tooltip.innerText = item.help || ''
            }
            childOptions.update = errors.update
        </script></span>
      &nbsp;</div>
      <div id="shell">
        <script>
          const shell = document.scripts[document.scripts.length - 1].parentNode;
          shell.sendCommand = function() {
            if (this.input.innerText.trim()) {
              this.oncommand(input.innerText.trim())
              this.input.changeText('')
              cmdBuffer.draftCommand = null
            } else {
              input.focus()
            }
          }
        </script>
        <span id='shellPrefix' class='title' onclick='input.resetSelection()'><span class='hidden'>Understandable </span>Password&gt; </span><span id='shellInput' class="unstyled" contenteditable spellcheck='false'><script>
          const input = document.scripts[document.scripts.length - 1].parentNode
          input.shellPrefix= document.getElementById('shellPrefix')
          console.log(input.shellPrefix, document.getElementById('shellPrefix'))
          // Tie parent's command with input content
          input.parentNode.input = input
          input.resetSelection = function () {
            // Select the end of input text
            this.focus()
            if (this.innerText) {
              const range = document.createRange();
              range.selectNodeContents(this);
              range.setStart(range.startContainer, 1)
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
          input.resetSelection()
          const enterKey = 13
          const downKey = 40
          const upKey = 38
          // Intercept Enter, Up, and Down key
          input.onkeydown = function(e) {
            if ([enterKey, upKey, downKey].includes(e.keyCode))
              e.preventDefault()
          }
          input.changeText = function(text) {
            text = text.replaceAll(nonbreakHyphen, '-').replaceAll(nonbreakSpace, ' ')
            if (text != this.innerText) {
              this.innerText = text
              this.onchange(text)
            }
            input.resetSelection()
          }
          input.onkeyup = function(e) {
            if (e.keyCode === enterKey) {
              this.parentNode.sendCommand()
              e.preventDefault()
            }
            if (e.keyCode === downKey)
              this.onnavigate(-1)
            if (e.keyCode === upKey)
              this.onnavigate(1)
            this.onchange(this.innerText)
          }
          input.onblur = function() {
            this.onchange(input.innerText)
          }
        </script></span><span onclick='input.resetSelection()'>&nbsp;</span><span class='icon button' onclick='this.parentNode.sendCommand()'><span class='hidden'>run&nbsp;</span>&nbsp;&nbsp;&nbsp;
        <script>
          input.enterBtn = document.scripts[document.scripts.length - 1].parentNode
          input.enterBtn.style.backgroundImage = 'var(--icon-enter)'
        </script></span>
      </div>
      <hr/>
      <div id='doubleBuffer'>
        <div id='cmdBuffer' class='shellBuffer'>
          <script>
            const nonbreakHyphen = '\u2011'
            const cmdBuffer = document.scripts[document.scripts.length - 1].parentNode;
            const doubleBuffer = cmdBuffer.parentNode
            doubleBuffer.selected = null
            cmdBuffer.count = 0
            cmdBuffer.elemClick = function() {
              doubleBuffer.setSelected(Number(this.id.substring(1)), window.getSelection().toString() === '')
            }
            cmdBuffer.add = function(command) {
              const elem = document.createElement('div')
              elem.innerText = command.replaceAll('-', nonbreakHyphen)
              elem.id = 'c' + this.count++
              elem.onclick = this.elemClick
              this.prepend(elem)
              return elem
            }
            input.onnavigate = function(delta) {
              let selected = doubleBuffer.selected
              if (selected == null) {
                if (delta < 0 && cmdBuffer.count > 0) {
                  selected = cmdBuffer.count + delta
                }
              } else
                selected += delta
              if (selected >= cmdBuffer.count) {
                doubleBuffer.setSelected(null)
                console.assert(cmdBuffer.draftCommand != null)
                input.changeText(cmdBuffer.draftCommand || '')
                return
              }
              if (selected === null) return
              doubleBuffer.setSelected(selected, true)
            }
          </script>
        </div>
        <div class='bufferMap'></div>
        <div id='resultBuffer' class='shellBuffer'>
          <script>
            const outputs = document.scripts[document.scripts.length - 1].parentNode;
            outputs.count = 0
            outputs.add = function(text, subtext, tooltip) {
              const elem = document.createElement('div')
              elem.innerText = text
              if (subtext) {
                let subElem = document.createElement('span')
                subElem.className = 'subtext'
                subElem.innerText = ' - '
                elem.appendChild(subElem)
                subElem = document.createElement('span')
                subElem.className = 'subtext'
                subElem.innerText = subtext
                if (tooltip != null) {
                  makeTooltipTrigger(subElem)
                  subElem.tooltip.innerText = tooltip
                }
                elem.appendChild(subElem)
              }
              elem.id = 'c' + this.count++
              elem.onclick = cmdBuffer.elemClick
              this.prepend(elem)
              return elem
            }
            doubleBuffer.setSelected = function(value, setCmd) {
              if (cmdBuffer.draftCommand == null)
                cmdBuffer.draftCommand = input.innerText
              if (this.selected != null) {
                cmdBuffer.querySelector('#c' + this.selected)?.classList?.toggle('selected', false)
                outputs.querySelector('#c' + this.selected)?.classList?.toggle('selected', false)
              }
              let newSel = null
              if (value != null) {
                newSel = cmdBuffer.querySelector('#c' + value)
                newSel?.classList?.toggle('selected', true)
                outputs.querySelector('#c' + value)?.classList?.toggle('selected', true)
                if (setCmd)
                  input.changeText(newSel?.innerText || '')
              }
              this.selected = value
            }
          </script>
        </div>
      </div>
      <script src='wordlist/wordlist.js'></script>
      <script src='wordlist/generator.js'></script>
      <script>
        paramType = {
          int:{
            desc:'an integer',
            shortDesc:'int',
            check:num => !isNaN(num),
            parse:str => Number(str),
          },
          none:{
            noInput:true,
            parse:val => val,
            check:val => false,
          },
          string:{
            parse:val => val,
            check:val => false,
          },
        }
        paramType.intFrom = min => ({...paramType.int,
          desc:'an integer ≥ '+min,
          shortDesc:`intFrom(${min})`,
          check:num => isNaN(num) || num < min,
        })
        paramType.intUpto = max => ({...paramType.int,
          desc:'an integer ≤ '+max,
          shortDesc:`intUpto(${max})`,
          check:num => isNaN(num) || num > max,
        })
        paramType.intBetween = (min, max) => ({...paramType.int,
          desc:`an integer between ${min} and ${max}`,
          shortDesc:`intBetween(${min}, ${max})`,
          check:num => isNaN(num) || num < min || num > max,
        })
        paramType.choices = (name, choices) => ({...paramType.string,
          desc:'one of '+choices.join(', '),
          shortDesc:name,
          check:val => !choices.includes(val),
        })
        commands = {children:{
          generate:{
            help:'generate random meaningful passwords from a number of noun groups and connecting words',
            base:generator.phrase.combined,
            exclusions:[[['groupCount', 'groupSize', 'firstGroupSize'], 'strength']],
            prioritizedParam:['strength'],
            defaultParam:{groupCount:2, groupSize:2, firstGroupSize:null},
            param:{
              groupCount:{
                positional:true,
                type:paramType.intFrom(1),
                help:'set the number of noun groups',
              },
              groupSize:{
                positional:true,
                type:paramType.intBetween(1, 5),
                help:'set the size of each noun group',
              },
              firstGroupSize:{
                positional:true,
                suggestion:5,
                type:paramType.intBetween(1, 5),
                help:'set the size of the first noun group, to further control the size of the password',
              },
            },
            children:{
              strength:{
                base:generator.minEntropy,
                help:'set the password strength in number of bits',
                param:{
                  bitCount:{
                    type:paramType.intFrom(1),
                    positional:true,
                    required:true,
                    suggestion:64,
                    help:'the password strength',
                  }
                },
              },
              nounChain:{
                base:generator.nounGroup.randChain,
                help:'generate a chain of noun groups with a target number of bits of entropy',
                defaultParam:{groupSize:2},
                param:{
                  bitCount:{
                    type:paramType.intFrom(1),
                    positional:true,
                    required:true,
                    suggestion:64,
                    help:'the target number of bits',
                  },
                  groupSize:{
                    type:paramType.intFrom(1),
                    help:'maximum group size for the noun groups',
                  },
                },
              },
            },
          },
          theme:{
            base:setTheme,
            help:'set the theme of the page',
            param:{
              color:{
                type:paramType.choices('a color', colorList),
                positional:true,
                options:colorList.map(name => ({text:name, color:name})),
                help:'the color scheme for the theme',
              },
              dark:{
                help:'activate dark mode',
              },
            },
          },
        }}
        function prepCommand(command) {
          if (command.exclusions)
            for (let group of command.exclusions)
              for (let i = 0; i < group.length; i++)
                if (typeof group[i] === 'string')
                  group[i] = [group[i]]
          if (command.prioritizedParam)
            command.prioritizedParam.reverse()
          else
            command.prioritizedParam = []
          if (command.defaultParam == null)
            command.defaultParam = {}
          if (command.param)
            for (let name in command.param) {
              const param = command.param[name]
              param.suggestion = param.suggestion || command.defaultParam[name] || name
              if (param.type == null)
                param.type = paramType.none
            }
          for (let child in command.children)
            prepCommand(command.children[child])
        }
        prepCommand(commands)
        function getExclusions(command, name) {
          const result = []
          if (command.exclusions)
            for (let group of command.exclusions) {
              let inItem = null
              for (let item of group)
                if (item.includes(name)) {
                  inItem = item
                  break
                }
              if (inItem != null)
                for (let item of group)
                  if (item !== inItem)
                    result.push(...item)
            }
          return result
        }
        input.onchange = function(text) {
          if (text.trim() == input.oldCmd?.trim()) return
          input.oldCmd = text
          input.enterBtn.classList.toggle('hidden', !text.trim())
          suggestions.classList.toggle('hot', !text.trim())
          input.currentCmd = null
          input.paramValues = {}
          let noSuggestions = false
          let paramNames = null
          let paramIndex = 0
          function setCurrentCmd(value) {
            input.currentCmd = value
            paramNames = input.currentCmd.param
            paramIndex = 0
            if (paramNames)
              paramNames = Object.keys(paramNames)
          }
          setCurrentCmd(commands)
          let expectingParamName = null
          let excludedParams = []
          input.errorArr = []
          let position = 0
          let start = 0
          let commandStart = 0
          let commandEnd = 0
          function addError(text, longText, collapsed) {
            input.errorArr.push({text, longText, start, end:position, collapsed})
          }
          text.split(/\s/).forEach((word, i) => {
            start = position
            position += word.length + 1
            word = word.trim()
            if (word === '') return
            if (input.errorArr.length > 0)
              noSuggestions = true
            if (expectingParamName) {
              if (!word.startsWith('-')) {
                const param = input.currentCmd.param[expectingParamName]
                word = param.type.parse(word)
                if (param.type.check(word))
                  addError(`${expectingParamName} must be ${param.type.shortDesc}`, `parameter ${expectingParamName} must be ${param.type.desc}`)
                input.paramValues[expectingParamName] = word
                expectingParamName = null
                return
              } else
                addError(`expecting value for "${expectingParamName}"`)
            }
            if (input.currentCmd.children && word in input.currentCmd.children) {
              commandStart = start
              commandEnd = position
              excludedParams.push(...getExclusions(input.currentCmd, word))
              setCurrentCmd(input.currentCmd.children[word])
              return
            } else if (paramNames) {
              if (word.startsWith('--')) {
                word = word.substring(2)
                if (word in input.currentCmd.param) {
                  excludedParams.push(...getExclusions(input.currentCmd, word))
                  if ('variantOf' in input.currentCmd.param[word])
                    word = input.currentCmd.param[word].variantOf
                  input.paramValues[word] = true
                  const param = input.currentCmd.param[word]
                  if (word in input.currentCmd.defaultParam || param.required)
                    expectingParamName = word
                } else addError(`unknown switch --${word}`)
                return
              } else {
                for (; paramIndex < paramNames.length; paramIndex++) {
                  const paramName = paramNames[paramIndex]
                  const param = input.currentCmd.param[paramName]
                  if (param.positional) {
                    console.log(param.type)
                    word = param.type.parse(word)
                    console.log(param.type.check(word), word, colorList.includes(word))
                    if (param.type.check(word))
                      addError(`$${paramIndex+1} must be ${param.type.shortDesc}`, `parameter ${paramIndex+1} must be ${param.type.desc}`)
                    else
                      excludedParams.push(...getExclusions(input.currentCmd, paramName))
                    input.paramValues[paramName] = word
                    word = null
                    paramIndex++
                    break
                  }
                }
                if (word == null) return
              }
            }
            addError(`unexpected "${word}"`)
          })
          start = commandStart
          position = commandEnd
          for (const param in input.currentCmd.param)
            if (!(param in input.paramValues) && input.currentCmd.param[param].required)
              addError('expecting value for ' + param)
          let childArr = []
          let paramArr = []
          if (!noSuggestions) {
            if (input.currentCmd.children != null)
              childArr.push(...Object.keys(input.currentCmd.children)
                .filter(item => !excludedParams.includes(item))
                .map(item => ({text:item, help:input.currentCmd.children[item]?.help}))
              )
            if (input.currentCmd.param != null) {
              let firstPositional = true
              const paramNames = [...Object.keys(input.currentCmd.param)]
              for (const prioritized of input.currentCmd.prioritizedParam) {
                const index = paramNames.indexOf(prioritized)
                if (index >= 0) {
              console.log(paramNames)
                  paramNames.unshift(...param.splice(index, 1))
              console.log(paramNames)
                }
              }
              console.log(paramNames, input.paramValues, excludedParams)
              paramArr.push(...paramNames
                .map(item => {
                  let param = input.currentCmd.param[item]
                  if ('variantOf' in param || item in input.paramValues || excludedParams.includes(item))
                    return null
                  const result = {...param, text:''}
                  if (param.positional) {
                    if (firstPositional) {
                      firstPositional = false
                      result.text = '<' + item + '>'
                    }
                  }
                  if (!result.text)
                    result.text = '--' + item
                  return result
                })
                .filter(item => item != null)
              )
              console.log(paramArr)
            }
          }
          input.paramValues = {...input.currentCmd.defaultParam, ...input.paramValues}
          const noError = input.errorArr.length === 0
          input.enterBtn.classList.toggle('active', noError)
          input.enterBtn.style.backgroundImage = 'var(--' + (noError ? 'bg-icon-enter' : 'icon-enter') + ')'
          errors.update(input.errorArr)
          paramOptions.update(paramArr)
          childOptions.update(childArr)
        }
        input.onchange(input.innerText)
        shell.oncommand = function(cmd) {
          cmdBuffer.add(cmd)
          input.onchange(cmd)
          if (input.errorArr.length > 0)
            outputs.add(input.errorArr.map(item => item.text).join(', '))
          else {
            try {
              console.log(input.paramValues)
              const output = input.currentCmd.base(input.paramValues)
              if (typeof output === 'string')
                outputs.add(output)
              else
                outputs.add(output[0], `${Math.round(log2(output[1], 16)*100)/100} bits`, `that's out of ${output[1].toLocaleString()} posible passwords`)
            } catch (error) {
              console.error(error)
              outputs.add('unknown error, see console')
            }
          }
        }
      </script>
    </div>
  </body>
</html>
